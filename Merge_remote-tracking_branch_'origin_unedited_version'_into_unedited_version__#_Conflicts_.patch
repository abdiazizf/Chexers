Index: search.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- search.py	(date 1555068626000)
+++ search.py	(date 1555068657778)
@@ -15,16 +15,26 @@
 axial_directions = [(1, 0), (1, -1), (0, -1), (-1, 0), (-1, 1), (0, 1)]
 # possible jump directions
 axial_jump = [(2, 0), (2, -2), (0, -2), (-2, 0), (-2, 2), (0, 2)]
+<<<<<<< HEAD
 # goal hex for each colour
 goal = {'R': [(3, -3), (3, -2), (3, -1), (3, 0)], 'B': [(0, -3), (-1, -2), (-2, -1), (-3, 0)],
         'G': [(-3, 3), (-2, 3), (-1, 3), (0, 3)]}
 # off board co-ordinates for generating valid exit moves
 exit_hexes = {'R': [(4, -3), (4, -2), (4, -1)], 'B': [(-3, -1), (-2, -2), (-1, -3)], 'G': [(-3, 4), (-2, 4), (-1, 4)]}
+=======
+#goal for each colour
+goal = {'R': [(3, -3), (3,-2) , (3,-1) , (3, 0)] , 'B':[(0, -3), (-1,-2) , (-2,-1) , (-3, 0)] , 'G' :[(-3, 3), (-2, 3) , (-1, 3) , (0, 3)]}
+# off board co-ordinates for generating valid exit moves  
+exit_hexes = {'R': [(4, -3),(4,-2),(4,-1)] , 'B':[(-3,-1),(-2,-2),(-1,-3)] , 'G' :[(-3,4),(-2,4),(-1,4)]}
+
+def main():
+>>>>>>> origin/unedited_version
 
 
 def main():
     with open(sys.argv[1]) as file:
         data = json.load(file)
+<<<<<<< HEAD
 
     # converts board to dict
     board_dict = convert_json_to_board_dict(data)
@@ -65,14 +75,43 @@
 # Class for every node state
 class State:
     def __init__(self, state, pieces, parent, cost, target, move=None):
+=======
+        
+    #converts board to dict
+    board_dict = convert_json_to_board_dict(data)
+    pieces, target = create_piece_and_target_list(board_dict)
+    
+    print_board(board_dict,debug=True)
+    
+    #returns state of last piece
+    a = search(board_dict,pieces,target)
+    print_board(a.state, debug=True)
+    path = []
+    while a :
+        path.insert(0 ,a.pieces)
+        a=a.parent
+    print(path)
+    
+    
+#Class for every node state
+class State :
+    def __init__(self,state,pieces,parent,cost,target):
+>>>>>>> origin/unedited_version
         self.state = state
         self.pieces = pieces
         self.parent = parent
         self.cost = cost
         self.target = target
+<<<<<<< HEAD
         self.move = move
 
     # prints object as a board and not memory location of object
+=======
+        self.cost
+
+
+    #prints object as a board and not memory location of object
+>>>>>>> origin/unedited_version
     def __str__(self):
         return str(self.parent.action)
 
@@ -91,34 +130,63 @@
         successor_states = []
         exit_moves = []
         for piece in self.pieces:
+<<<<<<< HEAD
 
+            if piece in self.target:
+                # exit move applies
+                exit_moves.append(piece)
+
+            for i in axial_directions:
+                potential_moves = (piece[0] + i[0], piece[1] + i[1])
+
+                if potential_moves not in self.state or self.state[potential_moves] is not None:
+                    continue
+                legal_moves.append(potential_moves)
+
+            for i in axial_jump:
+                potential_jump = (piece[0] + i[0], piece[1] + i[1])
+                if potential_jump not in self.state or self.state[potential_jump] is not None:
+                    continue
+                elif self.state[(potential_jump[0] - (i[0] / 2), potential_jump[1] - (i[1] / 2))] is not None:
+                    legal_moves.append(potential_jump)
+                else:
+                    continue
+
+        # CREATE NEW STATE FOR EVERY POSSIBLE MOVE Ill maybe create a new method for this
+=======
+            
             if piece in self.target:
-                # exit move applies
+                # exit move applies 
                 exit_moves.append(piece)
-
+                
             for i in axial_directions:
-                potential_moves = (piece[0] + i[0], piece[1] + i[1])
-
+                potential_moves = (piece[0]+i[0], piece[1]+i[1])
+                
                 if potential_moves not in self.state or self.state[potential_moves] is not None:
                     continue
                 legal_moves.append(potential_moves)
-
-            for i in axial_jump:
+                
+    
+            for i in axial_jump :
                 potential_jump = (piece[0] + i[0], piece[1] + i[1])
                 if potential_jump not in self.state or self.state[potential_jump] is not None:
                     continue
-                elif self.state[(potential_jump[0] - (i[0] / 2), potential_jump[1] - (i[1] / 2))] is not None:
+                elif self.state[(potential_jump[0] - (i[0]/2), potential_jump[1] - (i[1] / 2))] is not None:
                     legal_moves.append(potential_jump)
                 else:
                     continue
+            
+         
 
-        # CREATE NEW STATE FOR EVERY POSSIBLE MOVE Ill maybe create a new method for this
+        #CREATE NEW STATE FOR EVERY POSSIBLE MOVE Ill maybe create a new method for this
+>>>>>>> origin/unedited_version
         index = 0
 
         for move in exit_moves:
             index = self.pieces.index(move)
             new_state = copy.deepcopy(self.state)
             new_piece = copy.deepcopy(self.pieces)
+<<<<<<< HEAD
 
             generated_by_move = Move(move, move, "EXIT")
 
@@ -126,10 +194,18 @@
             del new_piece[index]
             new_state[move] = None
             state = State(new_state, new_piece, self, 0, self.target, generated_by_move)
+=======
+            
+            #instead of swapping pieces want to delete one 
+            del new_piece[index]
+            new_state[move] = None
+            state = State(new_state,new_piece,self,self.cost + 1 ,self.target)
+>>>>>>> origin/unedited_version
             successor_states.append(state)
 
         for each in legal_moves:
             for piece in self.pieces:
+<<<<<<< HEAD
                 if valid_move_for_piece(piece, each):
                     # Create state from move for desire piece
                     index = self.pieces.index(piece)
@@ -137,18 +213,33 @@
                         generated_by_move = Move(piece, each, "MOVE")
                     else:
                         generated_by_move = Move(piece, each, "JUMP")
+=======
+                if valid_move_for_piece(piece, each): 
+                    # Create state from move for desire piece
+                    index = self.pieces.index(piece)
+>>>>>>> origin/unedited_version
 
             new_state = copy.deepcopy(self.state)
             new_piece = copy.deepcopy(self.pieces)
             temp = new_state[each]
+<<<<<<< HEAD
             new_state[each] = new_state[new_piece[index]]
             new_state[new_piece[index]] = temp
             new_piece[index] = each
             state = State(new_state, new_piece, self, self.cost + 1, self.target, generated_by_move)
+=======
+            new_state[each]= new_state[new_piece[index]]
+            new_state[new_piece[index]] = temp
+            new_piece[index] = each
+            state = State(new_state,new_piece,self,self.cost + 1 ,self.target)
+>>>>>>> origin/unedited_version
             successor_states.append(state)
+            
 
+
         return successor_states
 
+<<<<<<< HEAD
 
 # Checks if a move is valid for a specific piece
 def valid_move_for_piece(piece, move):
@@ -169,28 +260,70 @@
     return (q < 0 and r < 0) or (q >= 0 and r >= 0)
 
 
+# returns the distance between two axial hex coordinates
+def hex_distance(origin, goal):
+=======
+def valid_move_for_piece(piece,move):
+    
+    for direction in axial_directions:
+        new_move = piece[0]+direction[0], piece[1]+direction[1]
+        if new_move == move:
+            return True
+    return False
+
+def swap_pieces_in_state(move,new_state,piece):
+    return True
+
+# prints output for current move
+def print_move(origin, goal, move):
+    if move == "JUMP":
+        print("JUMP from ,",origin," to ",goal,".")
+    elif move == "MOVE":
+        print("MOVE from ,",origin," to ",goal,".")
+    elif move == "EXIT":
+        print("EXIT from ,",origin,".")
+
+
+def same_sign(q , r) :
+    return (q < 0 and r < 0)or (q>=0 and r>= 0)
+
 # returns the distance between two axial hex coordinates
 def hex_distance(origin, goal):
+    
+>>>>>>> origin/unedited_version
     distance_x = goal[0] - origin[0]
     distance_y = goal[1] - origin[1]
     if same_sign(distance_x, distance_y):
         return abs(distance_x + distance_y)
     else:
         return max(abs(distance_x), abs(distance_y))
+<<<<<<< HEAD
 
     return
+=======
+    
+    return 
+>>>>>>> origin/unedited_version
 
 
 # returns the sum of distances for each piece to the nearest target
 def heuristic(target, source):
     heuristic = 0
+<<<<<<< HEAD
     for piece in source:
+=======
+    for piece in source :
+>>>>>>> origin/unedited_version
         heuristic_list = []
         for goal in target:
             heuristic_list.append(hex_distance(piece, goal))
         heuristic += min(heuristic_list)
 
+<<<<<<< HEAD
     return heuristic
+=======
+    return  heuristic
+>>>>>>> origin/unedited_version
 
 
 def search(initial_state, pieces, target):
@@ -204,6 +337,7 @@
         current_node = queue.get()
 
         if not current_node.pieces:
+<<<<<<< HEAD
             return current_node
 
             # generate successor states of current node
@@ -212,9 +346,19 @@
 
             if tuple(successor.state.items()) not in vistited_states or new_cost < vistited_states[tuple(successor.state.items())] :
                 vistited_states[tuple(successor.state.items())] = new_cost
+=======
+            return current_node      
+        
+        # generate successor states of current node 
+        for successor in current_node.successor_board_states():
+            new_cost = successor.cost
+            
+            if tuple(successor.state.items()) not in vistited_states:
+>>>>>>> origin/unedited_version
                 priority = new_cost + heuristic(initial_state.target, successor.pieces)
                 queue.put(successor, priority)
 
+    # TODO: print output of final moves 
     return current_node
 
 
@@ -235,13 +379,23 @@
         board_dict[tuple(coordinate)] = 'BLK'
     for coordinate in coordinates:
         if coordinate not in board_dict:
+<<<<<<< HEAD
             board_dict[coordinate] = None
+
+    return board_dict
+
+
+# creates a list of all the pieces
+# creates a list of all the possible target nodes (ie theres a block on one target so we cant use it
+=======
+            board_dict[coordinate]= None
 
+
     return board_dict
 
-
-# creates a list of all the pieces
-# creates a list of all the possible target nodes (ie theres a block on one target so we cant use it
+#creates a list of all the pieces
+#creates a list of all the possible target nodes (ie theres a block on one target so we cant use it
+>>>>>>> origin/unedited_version
 
 def create_piece_and_target_list(board_dict):
     pieces = []
